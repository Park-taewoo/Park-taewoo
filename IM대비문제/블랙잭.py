# '.' : 돌이 없는 칸, 'o' : 돌이 있는 칸
# 오른쪽, 오른쪽아래대각선, 아래쪽, 왼쪽아래대각선으로 연속 5개나와야함(벡터의 방향성을 고려하면 이 4가지 케이스만 고려하면 된다.)
# arr에 오목이 존재하면 'YES', 존재하지 않으면 'NO' return
def A(arr):
    # 우,하,우하대,좌하대
    dr = [0,1,1,1]
    dc = [1,0,1,-1]
    for i in range(N):
        for j in range(N):
            if arr[i][j] == 'o': #탐색 중에 어떤 좌표가 돌이 놓여져있다면?
                for d in range(4): # 방향성을 고려해서
                    sx = i
                    sy = j # 질문: sx와 sy를 두 번째 for문 직후에 넣어도 되지 않음?
                    # 각 방향에 대한 확인을 시작하기 전에, sx = i와 sy = j를 사용하여 시작 위치 sx, sy를 현재 위치 i, j로 초기화합니다. 
                    # 이 초기화는 각 방향 검사를 시작하기 직전에 이루어져야 합니다. 따라서, 세 번째 for d in range(4): 반복문 직후에 이 초기화가 위치하는 것이 올바르며,
                    # 이는 각 방향에 대한 탐색을 시작할 때마다 기준점을 현재 위치로 재설정하기 위함입니다.
                    
                    # 각 방향으로 연속적으로 오목이 존재하는가?
                    cnt = 0 #방향이 바뀔때마다, cnt가 초기화된다!

                    #def안에 while문을 쓰면 좋은 이유는 return만 함수 중간에 넣어도 알아서 함수를 빠져 나오기 때문이다!
                    while 0 <= sx <= N-1 and 0 <= sy <= N-1 and arr[sx][sy] == 'o': # sx, sy의 범위를 설정한다. & 해당 좌표에 돌이 놓여져 있다면~
                        cnt += 1
                        sx  += dr[d]
                        sy  += dc[d]
                        # sx와 sy에 계속 해당 방향에 대해서 1씩 이동하면서, 범위 안에 있고, 그 좌표에 돌이 놓여져있다면, cnt도 증가시키고, 다시 그 다음 좌표로 옮겨서 확인할 것이다.
                    
                    # 각 방향으로 오목이 존재하는가
                    if cnt >= 5:
                        return 'YES'
    return 'NO'
                #   else:
                    #   질문: 여기서return 'NO'하면 안되나?
        # return 'NO'를 조건문 내에 배치하는 것에 대하여:
        # return 'NO'를 특정 위치에서 바로 사용하지 않는 이유는, 전체 배열에 대한 검사를 완료할 때까지 오목이 없다는 것을 확정할 수 없기 때문입니다. 
        # 함수 내에서 return 'YES'는 오목을 발견한 즉시 실행되어 함수를 종료시키지만, return 'NO'는 모든 가능한 위치와 방향에 대한 검사가 끝난 후에야 실행됩니다. 
        # 즉, 모든 검사를 마쳤음에도 불구하고 오목이 발검되지 않았을 때만 return 'NO'가 실행되어야 합니다. 따라서, else 구문 내에 바로 return 'NO'를 사용하는 것은 적절하지 않습니다.


# 테스트 케이스의 개수
T = int(input())
for tc in range(1,T+1):
    # N*N 크기의 판
    N = int(input())
    arr = [input() for _ in range(N)]

    print(f'#{tc} {A(arr)}') #질문: 가장 위 함수 정의할 때도 안 쪽에 arr 있었고, print문에도 arr가 있는데, 오류가 왜 안나는거지?
    # 함수 정의 내부와 외부에서 arr 사용에 대하여:

# 함수 내외에서 arr 사용을 일상생활에 비유해 설명하겠습니다. 상황을 쉽게 이해하기 위해, 집에서 사용하는 주방과 요리학교의 주방을 비교하는 상황을 생각해보세요.

# 집의 주방에는 냄비라는 이름의 냄비가 하나 있고, 요리학교의 주방에도 냄비라는 이름의 냄비가 있습니다. 집에서는 집의 냄비를 사용해서 음식을 만들고, 요리학교에서는 요리학교의 냄비를 사용해서 음식을 만듭니다.

# 여기서, 집의 주방은 함수 외부의 스코프에 해당하고, 요리학교의 주방은 함수 내부의 스코프에 해당합니다. 집에서 사용하는 냄비와 요리학교에서 사용하는 냄비는 같은 이름을 공유하지만, 사용되는 위치(스코프)가 다릅니다.
# 따라서, 집에서 어떤 요리를 하든 그것이 요리학교의 냄비에 영향을 주지 않으며, 반대로 요리학교에서 사용하는 냄비가 집의 냄비에 영향을 주지 않습니다.

# 프로그래밍에서도 이와 같은 원리가 적용됩니다. 함수 외부에서 정의된 arr와 함수 내부에서 매개변수로 받은 arr는 같은 이름을 공유하지만, 
# 각각 다른 스코프(위치)에 존재하기 때문에 서로 다른 "냄비"처럼 동작합니다. 함수 내부에서 arr를 사용하면, 그것은 함수에 전달된 인자를 참조하며, 
# 함수 외부의 arr는 영향을 받지 않습니다. 이렇게 스코프를 통해 같은 이름의 변수가 서로 다른 환경에서 독립적으로 사용될 수 있는 것입니다.