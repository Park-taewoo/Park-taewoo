# 플이 1
# 두 기차가 부딪히기 전까지 소모된 시간 동안, 파리가 움직인 거리를 구하면 되는 문제
# - T = 두 기차가 충돌하기 까지 시간
# - A*T : A기차가 충동하기까지 이동한 거리
# - B*T : B기차가 충돌하기 까지 이동한 거리

# AT + BT = (A+B)T = 250m

# 풀이2
# 두 기차가 부딪히기 전까지 소모된 시간 동안 파리가 움직인 거리를 구하면 되는 문제
# -파리의 속도 = F 이므로, 정답은 FxT가 된다.
# -T=250/(A+B)*F

# 유의사항(중요.. 그러니까 반대로 해봐서 결과물을 한 번 체크해 보자!)
# -나눗셈(/)을 먼저 하면, 오차가 발생하고
# - 오차에 F를 곱하면 오차가 더욱 커진다.
# - 따라서 T =250xF/(A+B)처럼 F를 먼저 곱한 후 (A+B)로 니누면, 더 정확한 값이 나온다.

T = int(input())
for tc in range(1, T+1):
    #D: 두 기차의 거리, A: A의 속력, B의 속력, F: 파리의 속력
    D, A, B, F = map(int,input().split())
    T = D*F/(A+B)
    print(f'#{tc} {T}')

#<오차>에 대한 설명..
# 
# 수학적으로 T = 250/(A+B)*F와 T = 250xF/(A+B)는 같은 수식처럼 보이지만, 컴퓨터 프로그래밍에서는 두 수식이 실제로 다른 결과를 낼 수 있습니다. 
# 이 차이는 컴퓨터가 실수(floating-point numbers)를 처리하는 방식과 관련이 있습니다.
# 컴퓨터에서 실수를 처리할 때는 정밀도에 한계가 있기 때문에, 연산 순서에 따라 미세한 오차가 발생할 수 있습니다. 
# 특히, 나눗셈 연산을 먼저 수행하면 그 결과에 이미 오차가 발생할 수 있으며, 이후에 다른 연산을 적용하면 이 오차가 더욱 확대될 수 있습니다.
# bla~bla~
# 결론: 더 정밀한 계산이 필요한 경우에는 곱셈을 먼저 수행하는 것이 일반적으로 권장됩니다(중요: 결론만 암기하자!)